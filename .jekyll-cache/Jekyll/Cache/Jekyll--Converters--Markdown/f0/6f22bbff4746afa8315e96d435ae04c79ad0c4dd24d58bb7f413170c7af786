I"*<ul id="markdown-toc">
  <li><a href="#冒泡排序--bubble-sort" id="markdown-toc-冒泡排序--bubble-sort">冒泡排序 – Bubble Sort</a></li>
  <li><a href="#选择排序--selection-sort" id="markdown-toc-选择排序--selection-sort">选择排序 – Selection Sort</a></li>
  <li><a href="#插入排序--insertion-sort" id="markdown-toc-插入排序--insertion-sort">插入排序 – Insertion Sort</a></li>
  <li><a href="#希尔排序--shell-sort" id="markdown-toc-希尔排序--shell-sort">希尔排序 – Shell Sort</a></li>
  <li><a href="#堆排序--heap-sort" id="markdown-toc-堆排序--heap-sort">堆排序 – Heap Sort</a></li>
  <li><a href="#归并排序--merge-sort" id="markdown-toc-归并排序--merge-sort">归并排序 – Merge Sort</a></li>
  <li><a href="#快速排序--quck-sort" id="markdown-toc-快速排序--quck-sort">快速排序 – Quck Sort</a></li>
  <li><a href="#桶排序--bucket-sort" id="markdown-toc-桶排序--bucket-sort">桶排序 – Bucket Sort</a></li>
  <li><a href="#二分查找" id="markdown-toc-二分查找">二分查找</a></li>
</ul>

<p><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a>提供了数据结构和算法的动画演示。</p>

<p>不同的排序算法性质有所不同，衡量算法的效率，通常是用资源，例如<code class="highlighter-rouge">CPU</code>(时间)占用、内存占用、硬盘占用和网络占用。当讨论大<code class="highlighter-rouge">O</code>表示法时，一般考虑的是<code class="highlighter-rouge">CPU</code>占用。</p>

<p>排序算法是重要的，因为排序算法是二分查找的第一个步骤。</p>

<p><code class="highlighter-rouge">JavaScript</code>的<code class="highlighter-rouge">Array</code>类定义了一个<code class="highlighter-rouge">sort</code>函数(<code class="highlighter-rouge">Array.prototype.sort</code>)用以排序<code class="highlighter-rouge">JavaScript</code>数组。<code class="highlighter-rouge">ECMAScript</code>没有定义用哪个排序算法，所以浏览器厂商可以自己去定义。</p>

<!-- more -->

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">sort</span><span class="p">());</span> <span class="c1">//[1, 10, 11, 2, 5, 7]</span>
</code></pre></div></div>

<p>这是因为<code class="highlighter-rouge">sort</code>方法在对数组做排序时，把元素默认为字符串来比较的。但是，你可以传入自己的比较函数。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nx">sort</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">;</span>   <span class="c1">//按从大到小排序</span>
<span class="p">})</span>
</code></pre></div></div>

<p>我们还是关注排序算法把。</p>

<h2 id="冒泡排序--bubble-sort">冒泡排序 – Bubble Sort</h2>

<p>冒泡排序的动画演示: <a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Data Structure Visualizations</a></p>

<p>冒泡排序在所有的排序算法中是最简单的。因为基础算法包含内外两个循环，所以它的复杂度是 <code class="highlighter-rouge">O(n</code><sup><code class="highlighter-rouge">2</code></sup><code class="highlighter-rouge">)</code>。</p>

<p>冒泡排序是不断比较两个相邻的项，如果前一个比后一个大，则交换他们。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">bubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
                <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">index1</span><span class="p">,</span><span class="nx">index2</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">tem</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tem</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//code for testing</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">){</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">bubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>

<span class="cm">/**
*[ 4, 3, 2, 1, 5 ]
*[ 3, 2, 1, 4, 5 ]
*[ 2, 1, 3, 4, 5 ]
*[ 1, 2, 3, 4, 5 ]
*[ 1, 2, 3, 4, 5 ]
*/</span>
</code></pre></div></div>

<p>如果我们从内循环减去外循环中已跑过的轮数，可以避免不必要的比较，提高算法性能。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">modifiedBubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;</span><span class="nx">length</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
                <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">index1</span><span class="p">,</span><span class="nx">index2</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">tem</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tem</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="选择排序--selection-sort">选择排序 – Selection Sort</h2>

<p>选择排序的动画演示: <a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Data Structure Visualizations</a></p>

<p>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，依次类推。</p>

<p>该排序和冒泡排序一样，包含有嵌套的两个循环，也是一个复杂度为<code class="highlighter-rouge">O(n</code><sup><code class="highlighter-rouge">2</code></sup><code class="highlighter-rouge">)</code>的算法。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">selectionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">indexMin</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="nx">indexMin</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>

        <span class="c1">//find the minValue of arr, then swap arr[i] and arr[indexMin]</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">j</span><span class="o">=</span><span class="nx">i</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">indexMin</span><span class="p">]</span><span class="o">&gt;</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]){</span>
                <span class="nx">indexMin</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!==</span> <span class="nx">indexMin</span><span class="p">){</span>
            <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">indexMin</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">index1</span><span class="p">,</span><span class="nx">index2</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">tem</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tem</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//code for testing</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">){</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">selectionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>

<span class="cm">/**
*[ 1, 4, 3, 2, 5 ]
*[ 1, 2, 3, 4, 5 ]
*[ 1, 2, 3, 4, 5 ]
*[ 1, 2, 3, 4, 5 ]
*/</span>
</code></pre></div></div>

<hr />

<h2 id="插入排序--insertion-sort">插入排序 – Insertion Sort</h2>

<p>插入排序的动画演示: <a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Data Structure Visualizations</a></p>

<p>插入排序比冒泡和选择排序要好。插入排序每次排一个数组项，以此方式构建最后的排序数组。</p>

<ul>
  <li>排序从第二项开始，比较第二项与第一项，第二项则有可能插入到第一项之前或者保持原位不动</li>
  <li>这样，前两项已经排序，接着和第三项比较，第三项有可能插入到第一项或第二项之前，或者保持原位不动</li>
  <li>以此类推</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">temp</span><span class="p">,</span><span class="nx">j</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">){</span>
            <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="c1">//console.log(arr);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//code for testing</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">){</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>

<span class="cm">/**
*[ 4, 5, 3, 2, 1 ]
*[ 3, 4, 5, 2, 1 ]
*[ 2, 3, 4, 5, 1 ]
*[ 1, 2, 3, 4, 5 ]
*/</span>
</code></pre></div></div>

<p>排序小型数组时，插入排序比选择排序和冒泡排序性能要好。</p>

<hr />

<h2 id="希尔排序--shell-sort">希尔排序 – Shell Sort</h2>

<p>希尔排序的动画演示: <a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Data Structure Visualizations</a></p>

<p>希尔排序是按照设计者<code class="highlighter-rouge">Donald Shell</code>的名字命名的，该算法是插入排序的改进版本。准确来说，是一种分组的插入排序，能提高排序效率。</p>

<p>算法的思路是：</p>

<ul>
  <li>取一个正整数的步长<code class="highlighter-rouge">gap</code>，没有硬性要求<code class="highlighter-rouge">gap</code>的值，但我们通常取中间值</li>
  <li>这样，我们将原始数组切分成<code class="highlighter-rouge">gap</code>个组，所有距离为<code class="highlighter-rouge">gap</code>的倍数的数组项看成是一个组，然后，在各个小数组内进行插入排序</li>
  <li>更改步长<code class="highlighter-rouge">gap</code>的值，我们记为<code class="highlighter-rouge">gap_2</code>，则<code class="highlighter-rouge">gap_2 &lt; gap</code></li>
  <li>重复上面的步骤，直到<code class="highlighter-rouge">gap_i</code>的值为<code class="highlighter-rouge">1</code></li>
</ul>

<p>举例：我们有数组<code class="highlighter-rouge">numbers = [9,8,7,6,5,4,3,2,1]</code>，<code class="highlighter-rouge">numbers.length</code>的值是<code class="highlighter-rouge">9</code>，我们取<code class="highlighter-rouge">gap = Math.floor(9/2)</code>，为<code class="highlighter-rouge">4</code>。则分成<code class="highlighter-rouge">[9,5,1]</code>、<code class="highlighter-rouge">[8,4]</code>、<code class="highlighter-rouge">[7,3]</code>、<code class="highlighter-rouge">[6,2]</code>四个小数组，对这四个小数组进行排序为<code class="highlighter-rouge">[1,5,9]</code>、<code class="highlighter-rouge">[4,8]</code>、<code class="highlighter-rouge">[3,7]</code>、<code class="highlighter-rouge">[2,6]</code>，则整个数组变成<code class="highlighter-rouge">numbers = [1,4,3,2,5,8,7,6,9]</code>。更改<code class="highlighter-rouge">gap</code>的值，我们取<code class="highlighter-rouge">gap = Math.floor(gap/2)</code>，为<code class="highlighter-rouge">2</code>,则分成<code class="highlighter-rouge">[1,3,5,7,9]</code>、<code class="highlighter-rouge">[4,2,8,6]</code>两个小数组，操作同上。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">shellSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
    <span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">index1</span><span class="p">,</span><span class="nx">index2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">];</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">];</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">gap</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nx">gap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">gap</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">j</span> <span class="o">-=</span> <span class="nx">gap</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="nx">gap</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
                    <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">j</span><span class="o">-</span><span class="nx">gap</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span>
                <span class="k">else</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">gap</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">gap</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//code for testing</span>

<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">9</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">){</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">shellSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>

<span class="cm">/**
*[ 5, 8, 7, 6, 9, 4, 3, 2, 1 ]
*[ 5, 4, 7, 6, 9, 8, 3, 2, 1 ]
*[ 5, 4, 3, 6, 9, 8, 7, 2, 1 ]
*[ 5, 4, 3, 2, 9, 8, 7, 6, 1 ]
*[ 1, 4, 3, 2, 5, 8, 7, 6, 9 ]
*[ 1, 4, 3, 2, 5, 8, 7, 6, 9 ]
*[ 1, 2, 3, 4, 5, 8, 7, 6, 9 ]
*[ 1, 2, 3, 4, 5, 8, 7, 6, 9 ]
*[ 1, 2, 3, 4, 5, 8, 7, 6, 9 ]
*[ 1, 2, 3, 4, 5, 8, 7, 6, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*/</span>
</code></pre></div></div>

<hr />

<h2 id="堆排序--heap-sort">堆排序 – Heap Sort</h2>

<p>堆排序的动画演示: <a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Data Structure Visualizations</a></p>

<p>堆排序是利用完全二叉树最大堆和最小堆的原来来进行排序的。<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/">这篇文章描述得很好，可以参看</a>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">heapSort</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
        <span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">maxHeapify</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">heapSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">iMax</span><span class="p">,</span>
            <span class="nx">iLeft</span><span class="p">,</span>
            <span class="nx">iRight</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">iMax</span> <span class="o">=</span> <span class="nx">index</span><span class="p">;</span>
            <span class="nx">iLeft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nx">iRight</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">iLeft</span> <span class="o">&lt;</span> <span class="nx">heapSize</span> <span class="o">&amp;&amp;</span> <span class="nx">array</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">[</span><span class="nx">iLeft</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">iMax</span> <span class="o">=</span> <span class="nx">iLeft</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">iRight</span> <span class="o">&lt;</span> <span class="nx">heapSize</span> <span class="o">&amp;&amp;</span> <span class="nx">array</span><span class="p">[</span><span class="nx">iMax</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">[</span><span class="nx">iRight</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">iMax</span> <span class="o">=</span> <span class="nx">iRight</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">iMax</span> <span class="o">!=</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">swap</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">iMax</span><span class="p">,</span> <span class="nx">index</span><span class="p">);</span>
                <span class="nx">index</span> <span class="o">=</span> <span class="nx">iMax</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">buildMaxHeap</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span>
            <span class="nx">iParent</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">iParent</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">maxHeapify</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">buildMaxHeap</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">swap</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
            <span class="nx">maxHeapify</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//code for testing</span>

<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">9</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">){</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">heapSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<h2 id="归并排序--merge-sort">归并排序 – Merge Sort</h2>

<p>归并排序的动画演示: <a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Data Structure Visualizations</a></p>

<p>归并排序是第一个被实际使用的排序算法。这个算法的复杂度是<code class="highlighter-rouge">O(nlog</code><sup><code class="highlighter-rouge">n</code></sup><code class="highlighter-rouge">)</code>。</p>

<p>归并排序是一种分治算法，其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完成的大数组。</p>

<p>由于是分治法，所以是递归的。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">mergeSortRec</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">length</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
        <span class="nx">left</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">mid</span><span class="p">),</span>
        <span class="nx">right</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">mid</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">mergeSortRec</span><span class="p">(</span><span class="nx">left</span><span class="p">),</span><span class="nx">mergeSortRec</span><span class="p">(</span><span class="nx">right</span><span class="p">));</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">il</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">ir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">il</span> <span class="o">&lt;</span> <span class="nx">left</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">ir</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">left</span><span class="p">[</span><span class="nx">il</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">[</span><span class="nx">ir</span><span class="p">])</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">left</span><span class="p">[</span><span class="nx">il</span><span class="o">++</span><span class="p">]);</span>
        <span class="k">else</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">right</span><span class="p">[</span><span class="nx">ir</span><span class="o">++</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">il</span> <span class="o">&lt;</span> <span class="nx">left</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">left</span><span class="p">[</span><span class="nx">il</span><span class="o">++</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">ir</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">right</span><span class="p">[</span><span class="nx">ir</span><span class="o">++</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="c1">//console.log(res);</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如图执行过程。</p>

<p><img src="/styles/images/algorithms/mergeSort.jpg" alt="merge-insertion" /></p>

<ul>
  <li>在<code class="highlighter-rouge">mergeSortRec()</code>函数中，如果数组长度是1，则返回被分解最小的只有一个项的数组，因为它已经排序了，而且这也是我们递归的终止条件。</li>
  <li>如果数组长度大于1，我们就要将其分成小数组。为此，我们找到中间行，分成<code class="highlighter-rouge">left</code>和<code class="highlighter-rouge">right</code>两个小数组。</li>
  <li>然后，我们调用<code class="highlighter-rouge">merge()</code>函数，该函数用来合并和排序小数组。</li>
  <li>在<code class="highlighter-rouge">merge()</code>函数中，比较来自<code class="highlighter-rouge">left</code>数组的项是否比来自<code class="highlighter-rouge">right</code>的数组的项小，如果是，将<code class="highlighter-rouge">left</code>的数组添加至归并数组，然后将剩余的<code class="highlighter-rouge">right</code>剩余的项添加至归并数组，反之亦然。</li>
</ul>

<hr />

<h2 id="快速排序--quck-sort">快速排序 – Quck Sort</h2>

<p>快速排序的动画演示: <a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Data Structure Visualizations</a></p>

<p>快速排序也许是最常用的排序算法了。它的复杂度是<code class="highlighter-rouge">O(nlog</code><sup><code class="highlighter-rouge">n</code></sup><code class="highlighter-rouge">)</code>，且它的性能通常比其他的复杂度为<code class="highlighter-rouge">O(nlog</code><sup><code class="highlighter-rouge">n</code></sup><code class="highlighter-rouge">)</code>的排序算法好。</p>

<p>快速排序也是使用分治的方法，将原始数组分解为较小的数组。</p>

<ul>
  <li>首先，从数组中选择中间一项作为主元(当然，任选是合理的但并不是最优的)</li>
  <li>创建两个指针，左边一个指向数组第一项，右边一个指向数组最后一项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫划分操作。</li>
  <li>接着，算法对划分后的小数组重复之前的两个步骤，直至数组完全排序。</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">left</span><span class="p">,</span><span class="nx">right</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">index</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
        <span class="nx">index</span> <span class="o">=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">)</span>
            <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">index</span><span class="p">,</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">left</span><span class="p">,</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">pivot</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="nx">left</span><span class="p">,</span>
        <span class="nx">j</span> <span class="o">=</span> <span class="nx">right</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span><span class="nx">j</span><span class="p">){</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">pivot</span><span class="p">){</span>
            <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span>  <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">pivot</span><span class="p">){</span>
            <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">j</span><span class="p">){</span>
            <span class="nx">swapQuickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">);</span>
            <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
            <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">swapQuickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">index1</span><span class="p">,</span><span class="nx">index2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">index1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">];</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">index2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="桶排序--bucket-sort">桶排序 – Bucket Sort</h2>

<p>桶排序的动画演示: <a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html">Data Structure Visualizations</a></p>

<p>桶排序(Bucket Sort)是通过一定规则将数据放到不同的桶中去，然后对每个桶进行分别排序(使用其他排序方式，或利用递归继续使用桶排序)。排序过程如下:</p>

<ul>
  <li>待排的数据分布在一个范围内，对这一范围进行分割，分割为多个小范围</li>
  <li>待排的数据归档进入这些小范围，并对小范围的数据进行排序</li>
  <li>将各个子桶的数据有序归并</li>
</ul>

<p>举个栗子，我们有一组数:[29 25 3 49 9 37 21 43]，其中最大数为49。则我们可以设置5个桶，每个桶的范围是[0~9][10~19][20~29][30~39][40~49]。[3,9]放到第一个桶，[21,25,29]放到第三个桶，[37]放到第四个桶，[49,43]放到第五个桶。然后对每个桶的数进行排序，保证每个桶有序，然后将各个桶中的数据有序合并起来。如下图:</p>

<p><img src="/styles/images/algorithms/bucket-sort.png" alt="桶排序" /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">bucketSort</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">step</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">bucket</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">bucketCount</span><span class="p">,</span>
        <span class="nx">l</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">i</span><span class="p">,</span>
        <span class="nx">j</span><span class="p">,</span>
        <span class="nx">k</span><span class="p">,</span>
        <span class="nx">s</span><span class="p">,</span>
        <span class="nx">max</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="nx">min</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="nx">temp</span><span class="p">;</span>

    <span class="nx">max</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">));</span>
    <span class="nx">min</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="nx">bucketCount</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">((</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span><span class="p">)</span> <span class="o">/</span> <span class="nx">step</span><span class="p">);</span> <span class="c1">// 需要桶的数量</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">temp</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">bucketCount</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">temp</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nx">min</span> <span class="o">+</span> <span class="nx">step</span> <span class="o">*</span> <span class="nx">j</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">temp</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="nx">min</span> <span class="o">+</span> <span class="nx">step</span> <span class="o">*</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span> <span class="c1">// 判断放入哪个桶</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="p">}</span>
                <span class="c1">// 通过插入排序将数字插入到桶中的合适位置</span>
                <span class="nx">s</span> <span class="o">=</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="nx">k</span> <span class="o">=</span> <span class="nx">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">)</span> <span class="p">{</span>
                            <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">k</span><span class="p">];</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bucketCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 循环取出桶中数据</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">k</span> <span class="o">=</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bucketSort</span><span class="p">([</span><span class="mi">29</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">43</span><span class="p">],</span> <span class="mi">10</span><span class="p">));</span>
</code></pre></div></div>

<blockquote>
  <p><a href="http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/">代码参考</a>，健壮性有待提高</p>
</blockquote>

<hr />

<h2 id="二分查找">二分查找</h2>

<ul>
  <li>选择数组中间的值</li>
  <li>如果选中值是待搜索值，结束</li>
  <li>如果待搜索值比选中值要小，返回步骤1并在选中值左边的子数组中寻找</li>
  <li>如果待搜索值比选中值要大，返回步骤1并在选中值右边的子数组中寻找</li>
</ul>

<p>所以，在二分查找前，我们需要将数组项排序。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">item</span><span class="p">){</span>
    <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">high</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">mid</span><span class="p">,</span> <span class="nx">element</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">low</span> <span class="o">&lt;=</span> <span class="nx">high</span><span class="p">){</span>
        <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">low</span> <span class="o">+</span> <span class="nx">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
        <span class="nx">element</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">element</span> <span class="o">&lt;</span> <span class="nx">item</span><span class="p">){</span>
            <span class="nx">low</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">element</span> <span class="o">&gt;</span> <span class="nx">item</span><span class="p">){</span>
            <span class="nx">high</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mid</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
:ET